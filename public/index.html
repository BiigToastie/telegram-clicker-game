<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="default-src * 'self' 'unsafe-inline' 'unsafe-eval' data: telegram.org *.telegram.org">
    <title>Clicker Game</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="game.js"></script>
    <audio id="bgMusic" loop>
        <source src="music/background.mp3" type="audio/mp3">
    </audio>
    <style>
        /* All existing styles remain unchanged */
        /* ... */
    </style>
</head>
<body>
    <!-- All existing HTML content remains unchanged -->
    <script>
        window.addEventListener('load', () => {
            const tg = window.Telegram.WebApp;
            tg.expand();
            tg.ready();
            
            // Musik-Setup
            const bgMusic = document.getElementById('bgMusic');
            const musicControl = document.getElementById('musicControl');
            const volumeSlider = document.getElementById('volumeSlider');
            
            // Setze initiale LautstÃ¤rke
            bgMusic.volume = 0.5;
            
            // Musik starten wenn bereit
            bgMusic.addEventListener('canplaythrough', () => {
                bgMusic.play().catch(error => {
                    console.log('Autoplay prevented:', error);
                });
            });
            
            // LautstÃ¤rke-Kontrolle
            volumeSlider.addEventListener('input', (e) => {
                const volume = e.target.value / 100;
                bgMusic.volume = volume;
                musicControl.classList.toggle('muted', volume === 0);
            });
            
            // Musik Toggle
            musicControl.addEventListener('click', () => {
                if (bgMusic.paused) {
                    bgMusic.play();
                    musicControl.classList.remove('muted');
                } else {
                    bgMusic.pause();
                    musicControl.classList.add('muted');
                }
            });

            let gameState = {
                coins: 0,
                multiplier: 0.1,
                level: {
                    current: 0,
                    exp: 0,
                    nextLevel: 100
                },
                upgrades: {
                    multiplier: {
                        cost: 5,
                        increment: 0.1,
                        costIncrease: 1.3
                    },
                    autoClicker: {
                        active: false,
                        cost: 100,
                        value: 0.1,
                        upgradeCost: 200,
                        costIncrease: 1.5,
                        lastUpdate: Date.now()
                    }
                }
            };

            // Automatisches Speichern alle 1 Sekunde
            setInterval(() => {
                saveUserData();
            }, 1000);

            let autoClickerInterval;

            function calculateOfflineProgress() {
                if (gameState.upgrades.autoClicker.active && gameState.upgrades.autoClicker.lastUpdate) {
                    const now = Date.now();
                    const timeDiff = now - gameState.upgrades.autoClicker.lastUpdate;
                    const seconds = Math.floor(timeDiff / 1000);
                    
                    if (seconds > 0) {
                        const offlineCoins = seconds * gameState.upgrades.autoClicker.value;
                        gameState.coins += offlineCoins;
                        showToast(`ðŸ¤– WÃ¤hrend du weg warst:\n+${offlineCoins.toFixed(2)} Coins in ${seconds} Sekunden!`);
                    }
                    
                    gameState.upgrades.autoClicker.lastUpdate = now;
                    saveUserData();
                }
            }

            // Auto-Clicker Status und Anzeige initialisieren
            function initializeAutoClicker() {
                if (gameState.upgrades.autoClicker.active) {
                    const status = document.getElementById('autoClickerStatus');
                    const autoClickValue = document.getElementById('autoClickValue');
                    
                    // Zeige Auto-Clicker Wert an
                    autoClickValue.style.display = 'inline-block';
                    document.getElementById('autoClickerBuy').style.display = 'none';
                    document.getElementById('autoClickerUpgrade').style.display = 'flex';
                    
                    // Status-Button aktualisieren
                    status.classList.remove('locked');
                    
                    // Wenn der Auto-Clicker aktiviert war, starte ihn neu
                    if (gameState.upgrades.autoClicker.enabled) {
                        status.classList.add('active');
                        startAutoClicker();
                        console.log('Auto-Clicker automatisch gestartet');
                    }
                }
            }

            // Lade Spielerdaten
            async function loadUserData() {
                try {
                    const telegramId = tg.initDataUnsafe?.user?.id;
                    if (!telegramId) return;

                    const response = await fetch(`/api/user/${telegramId}`);
                    const userData = await response.json();
                    
                    gameState = {
                        coins: Number(userData.coins || 0),
                        multiplier: Number(userData.multiplier || 0.1),
                        level: {
                            current: Number(userData.level?.current || 0),
                            exp: Number(userData.level?.exp || 0),
                            nextLevel: Number(userData.level?.nextLevel || 100)
                        },
                        upgrades: {
                            multiplier: {
                                cost: Number(userData.upgrades?.multiplier?.cost || 5),
                                increment: Number(userData.upgrades?.multiplier?.increment || 0.1),
                                costIncrease: Number(userData.upgrades?.multiplier?.costIncrease || 1.3)
                            },
                            autoClicker: {
                                active: Boolean(userData.upgrades?.autoClicker?.active || false),
                                enabled: Boolean(userData.upgrades?.autoClicker?.enabled || false),
                                cost: Number(userData.upgrades?.autoClicker?.cost || 100),
                                value: Number(userData.upgrades?.autoClicker?.value || 0.1),
                                upgradeCost: Number(userData.upgrades?.autoClicker?.upgradeCost || 200),
                                costIncrease: Number(userData.upgrades?.autoClicker?.costIncrease || 1.5),
                                lastUpdate: Number(userData.upgrades?.autoClicker?.lastUpdate || Date.now())
                            }
                        }
                    };

                    // Initialisiere Auto-Clicker und berechne Offline-Fortschritt
                    initializeAutoClicker();
                    calculateOfflineProgress();
                    
                    updateDisplay();
                } catch (error) {
                    console.error('Fehler beim Laden:', error);
                }
            }

            // Rest of the existing JavaScript code remains unchanged
            // ...
        });
    </script>
</body>
</html>